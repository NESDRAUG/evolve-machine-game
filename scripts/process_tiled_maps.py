#!/usr/bin/env python3

import argparse
import sys
import xml.etree.ElementTree as ET
from pathlib import Path
from struct import *

def main(fin: Path, fout: Path):
  fout.mkdir(parents=True, exist_ok=True)

  for file in (fin / "tiled").rglob('*.tmx'):
    root = ET.parse(file).getroot()
    solid_collision = []
    objcollision = root.find('./objectgroup[@name="collision"]')
    for obj in objcollision.findall('object'):
      solid_collision.append([
        int(obj.attrib["x"]),
        int(obj.attrib["y"]),
        int(obj.attrib["width"]),
        int(obj.attrib["height"]),
      ])
    lead_exits = []
    side_exits = []
    objexits = root.find('./objectgroup[@name="exit_spawns"]')
    for objname in ["top_up", "top_right", "top_down", "top_left"]:
      obj = objexits.find(f'./object[@name="{objname}"]')
      if obj:
        lead_exits.append([
          int(obj.attrib["x"]) // 8,
          int(obj.attrib["y"]) // 8,
          int(obj.attrib["width"]),
          int(obj.attrib["height"]),
        ])
      else:
        lead_exits.append([0,0,0,0])
    for objname in ["bot_up", "bot_right", "bot_down", "bot_left"]:
      obj = objexits.find(f'./object[@name="{objname}"]')
      if obj:
        side_exits.append([
          int(obj.attrib["x"]) // 8,
          int(obj.attrib["y"]) // 8,
          int(obj.attrib["width"]),
          int(obj.attrib["height"]),
        ])
      else:
        side_exits.append([0,0,0,0])

    with open(fout / "header" / f"room_collision.s", 'w') as asm:
      asm.write(f"""
;;; Generated by process_tiled_maps.py

;; Room collision data
; x lo
.byte {",".join([str(x[0]) + "@mos16lo" for x in solid_collision])}
; x hi
.byte {",".join([str(x[0]) + "@mos16hi" for x in solid_collision])}
; y lo
.byte {",".join([str(x[1]) + "@mos16lo" for x in solid_collision])}
; y hi
.byte {",".join([str(x[1]) + "@mos16hi" for x in solid_collision])}
; width
.byte {",".join([str(x[2]) for x in solid_collision])}
; height
.byte {",".join([str(x[3]) for x in solid_collision])}

;; lead exits
; x lo
.byte {",".join([str(x[0]) + "@mos16lo" for x in lead_exits])}
; x hi
.byte {",".join([str(x[0]) + "@mos16hi" for x in lead_exits])}
; y lo
.byte {",".join([str(x[1]) + "@mos16lo" for x in lead_exits])}
; y hi
.byte {",".join([str(x[1]) + "@mos16hi" for x in lead_exits])}
; width
.byte {",".join([str(x[2]) for x in lead_exits])}
; height
.byte {",".join([str(x[3]) for x in lead_exits])}

;; side exits
; x lo
.byte {",".join([str(x[0]) + "@mos16lo" for x in side_exits])}
; x hi
.byte {",".join([str(x[0]) + "@mos16hi" for x in side_exits])}
; y lo
.byte {",".join([str(x[1]) + "@mos16lo" for x in side_exits])}
; y hi
.byte {",".join([str(x[1]) + "@mos16hi" for x in side_exits])}
; width
.byte {",".join([str(x[2]) for x in side_exits])}
; height
.byte {",".join([str(x[3]) for x in side_exits])}

""")


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Processes Metasprites and outputs to header files')
  
  parser.add_argument('fin', metavar='in', type=str,
                      help='Input Directory of msb files to build the song data from')
  parser.add_argument('fout', metavar='out', type=str,
                      help='Build Directory to write the output files to.')
                      
  args = parser.parse_args()
  main(Path(args.fin).resolve(), Path(args.fout).resolve())
